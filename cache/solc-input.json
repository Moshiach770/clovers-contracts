{
  "language": "Solidity",
  "sources": {
    "contracts/v5/CloversController.sol": {
      "content": "pragma solidity ^0.5.8;\n\n/**\n * The CloversController is a replaceable endpoint for minting and unminting Clovers.sol and ClubToken.sol\n */\n\nimport \"./Reversi.sol\";\nimport \"./IAMB.sol\";\nimport \"./IClovers.sol\";\nimport \"./IClubToken.sol\";\nimport \"./IClubTokenController.sol\";\nimport \"./ISimpleCloversMarket.sol\";\nimport \"./POACloversController.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\ncontract CloversController is Ownable {\n    event cloverClaimed(uint256 tokenId, bytes28[2] moves, address sender, address recipient, uint reward, uint256 symmetries, bool keep);\n    event cloverChallenged(uint256 tokenId, bytes28[2] moves, address owner, address challenger);\n\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n\n    bool public paused;\n    address public oracle;\n    IClovers public clovers;\n    IClubToken public clubToken;\n    IClubTokenController public clubTokenController;\n    ISimpleCloversMarket public simpleCloversMarket;\n    IAMB public amb;\n    function getAMB() public view returns(address) {\n        return address(amb);\n    }\n    address public poaCloversController;\n\n    uint256 public gasLastUpdated_fastGasPrice_averageGasPrice_safeLowGasPrice;\n    uint256 public gasBlockMargin = 240; // ~1 hour at 15 second blocks\n\n    uint256 public basePrice;\n    uint256 public priceMultiplier;\n    uint256 public payMultiplier;\n\n    mapping(bytes32=>address) public commits;\n\n    modifier notPaused() {\n        require(!paused, \"Must not be paused\");\n        _;\n    }\n\n    modifier fromAMB() {\n        require(msg.sender == address(amb), \"Only AMB can do that\");\n        require(amb.messageSender() == poaCloversController, \"AMB didn't originate from POACloversController\");\n        _;\n    }\n\n    constructor(\n        IClovers _clovers,\n        IClubToken _clubToken,\n        IClubTokenController _clubTokenController,\n        IAMB _amb\n    ) public {\n        clovers = _clovers;\n        clubToken = _clubToken;\n        clubTokenController = _clubTokenController;\n        amb = _amb;\n        paused = true;\n    }\n\n    function getMovesHash(bytes28[2] memory moves) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(moves));\n    }\n\n    function getMovesHashWithRecipient(bytes32 movesHash, address recipient) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(movesHash, recipient));\n    }\n\n    /**\n    * @dev Checks whether the game is valid.\n    * @param moves The moves needed to play validate the game.\n    * @return A boolean representing whether or not the game is valid.\n    */\n    function isValid(bytes28[2] memory moves) public pure returns (bool) {\n        Reversi.Game memory game = Reversi.playGame(moves);\n        return isValidGame(game.error, game.complete);\n    }\n\n    /**\n    * @dev Checks whether the game is valid.\n    * @param error The pre-played game error\n    * @param complete The pre-played game complete boolean\n    * @return A boolean representing whether or not the game is valid.\n    */\n    function isValidGame(bool error, bool complete) public pure returns (bool) {\n        if (error || !complete) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function getGame (bytes28[2] memory moves) public pure returns (bool error, bool complete, bool symmetrical,\n        bytes16 board, uint8 currentPlayer, uint8 moveKey) {\n        // return Reversi.getGame(moves);\n        Reversi.Game memory game = Reversi.playGame(moves);\n        return (\n            game.error,\n            game.complete,\n            game.symmetrical,\n            game.board,\n            game.currentPlayer,\n            game.moveKey\n            // game.msg\n        );\n    }\n    /**\n    * @dev Calculates the reward of the board.\n    * @param symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry types.\n    * @return A uint256 representing the reward that would be returned for claiming the board.\n    */\n    function calculateReward(uint256 symmetries) public view returns (uint256) {\n        uint256 Symmetricals;\n        uint256 RotSym;\n        uint256 Y0Sym;\n        uint256 X0Sym;\n        uint256 XYSym;\n        uint256 XnYSym;\n        (Symmetricals,\n        RotSym,\n        Y0Sym,\n        X0Sym,\n        XYSym,\n        XnYSym) = clovers.getAllSymmetries();\n        uint256 base = 0;\n        if (symmetries >> 4 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(RotSym + 1));\n        if (symmetries >> 3 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(Y0Sym + 1));\n        if (symmetries >> 2 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(X0Sym + 1));\n        if (symmetries >> 1 & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XYSym + 1));\n        if (symmetries & 1 == 1) base = base.add(payMultiplier.mul(Symmetricals + 1).div(XnYSym + 1));\n        return base;\n    }\n\n    function getPrice(uint256 symmetries) public view returns(uint256) {\n        return basePrice.add(calculateReward(symmetries));\n    }\n\n    // In order to prevent commit reveal griefing the first commit is a combined hash of the moves and the recipient.\n    // In order to use the same commit mapping, we mark this hash simply as address(1) so it is no longer the equivalent of address(0)\n    function claimCloverSecurelyPartOne(bytes32 movesHashWithRecipient, address recipient) public {\n        commits[movesHashWithRecipient] = address(1);\n        commits[keccak256(abi.encodePacked(recipient))] = address(block.number);\n    }\n\n    // Once a commit has been made to guarantee the move hash is associated with the recipient we can make a commit on the hash of the moves themselves\n    // If we were to make a claim on the moves in plaintext, the transaction could be front run on the claimCloverWithVerification or the claimCloverWithSignature\n    function claimCloverSecurelyPartTwo(bytes32 movesHash, address recipient) public {\n        require(uint256(commits[keccak256(abi.encodePacked(recipient))]) < block.number, \"Can't combine step1 with step2\");\n        bytes32 commitHash = getMovesHashWithRecipient(movesHash, recipient);\n        address commitOfMovesHashWithRecipient = commits[commitHash];\n        require(\n            address(commitOfMovesHashWithRecipient) == address(1),\n            \"Invalid commitOfMovesHashWithRecipient, please do claimCloverSecurelyPartOne\"\n        );\n        delete(commits[commitHash]);\n        commits[movesHash] = recipient;\n    }\n\n    function claimCloverWithVerification(bytes28[2] memory moves, bool keep, address recipient) public payable returns (bool) {\n        bytes32 movesHash = getMovesHash(moves);\n        address committedRecipient = commits[movesHash];\n        require(committedRecipient == address(0) || committedRecipient == recipient, \"Invalid committedRecipient\");\n\n        Reversi.Game memory game = Reversi.playGame(moves);\n        require(isValidGame(game.error, game.complete), \"Invalid game\");\n        uint256 tokenId = convertBytes16ToUint(game.board);\n        require(!clovers.exists(tokenId), \"Clover already exists\");\n\n        uint256 symmetries = Reversi.returnSymmetricals(game.RotSym, game.Y0Sym, game.X0Sym, game.XYSym, game.XnYSym);\n        require(_claimClover(tokenId, moves, symmetries, recipient, keep), \"Claim must succeed\");\n        delete(commits[movesHash]);\n        return true;\n    }\n\n    /**\n    * @dev Claim the Clover without a commit or reveal. Payable so you can buy tokens if needed.\n    * @param tokenId The board that results from the moves.\n    * @param moves The moves that make up the Clover reversi game.\n    * @param symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * @param keep symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * @param signature symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * types.\n    * @return A boolean representing whether or not the claim was successful.\n    */\n\n    /* solium-disable-next-line  max-len */\n    function claimCloverWithSignature(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, bytes memory signature, address recipient)\n        public payable notPaused returns (bool) {\n        address committedRecipient = commits[getMovesHash(moves)];\n        require(committedRecipient == address(0) || committedRecipient == recipient, \"Invalid committedRecipient\");\n        require(!clovers.exists(tokenId), \"Clover already exists\");\n        require(checkSignature(tokenId, moves, symmetries, keep, recipient, signature, oracle), \"Invalid Signature\");\n        require(_claimClover(tokenId, moves, symmetries, recipient, keep), \"Claim must succeed\");\n        return true;\n    }\n\n    function claimCloverFromAMB(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, address recipient)\n        public payable notPaused fromAMB returns (bool) {\n        address committedRecipient = commits[getMovesHash(moves)];\n        require(committedRecipient == address(0) || committedRecipient == recipient, \"Invalid committedRecipient\");\n        require(!clovers.exists(tokenId), \"Clover already exists\");\n        require(_claimClover(tokenId, moves, symmetries, recipient, keep), \"_claimClover failed\");\n        return true;\n    }\n\n    function _claimClover(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, address recipient, bool keep) internal returns (bool) {\n        clovers.setCloverMoves(tokenId, moves);\n        clovers.setKeep(tokenId, keep);\n        uint256 reward;\n        if (symmetries > 0) {\n            clovers.setSymmetries(tokenId, symmetries);\n            reward = calculateReward(symmetries);\n            clovers.setReward(tokenId, reward);\n            addSymmetries(symmetries);\n        }\n        uint256 price = basePrice.add(reward);\n        if (keep && price > 0) {\n            // If the user decides to keep the Clover, they must\n            // pay for it in club tokens according to the reward price.\n            if (clubToken.balanceOf(recipient) < price) {\n                clubTokenController.buy.value(msg.value)(recipient);\n            }\n            clubToken.burn(recipient, price);\n        }\n\n        if (keep) {\n            // If the user decided to keep the Clover\n            clovers.mint(recipient, tokenId);\n        } else {\n            // If the user decided not to keep the Clover, they will\n            // receive the reward price in club tokens, and the clover will\n            // go for sale by the contract.\n            clovers.mint(address(clovers), tokenId);\n            simpleCloversMarket.sell(tokenId, basePrice.add(reward.mul(priceMultiplier)));\n            if (reward > 0) {\n                require(clubToken.mint(recipient, reward), \"mint must succeed\");\n            }\n        }\n        emit cloverClaimed(tokenId, moves, recipient, recipient, reward, symmetries, keep);\n        return true;\n    }\n\n\n    /**\n    * @dev Convert a bytes16 board into a uint256.\n    * @param _board The board being converted.\n    * @return number the uint256 being converted.\n    */\n    function convertBytes16ToUint(bytes16 _board) public pure returns(uint256 number) {\n        for(uint i = 0; i < _board.length; i++){\n            number = number + uint(uint8(_board[i]))*(2**(8*(_board.length-(i+1))));\n        }\n    }\n\n\n    /**\n    * @dev Challenge a Clover for being invalid.\n    * @param tokenId The board being challenged.\n    * @return A boolean representing whether or not the challenge was successful.\n    */\n    function challengeClover(uint256 tokenId) public returns (bool) {\n        require(clovers.exists(tokenId), \"Clover must exist to be challenged\");\n        bool valid = true;\n        bytes28[2] memory moves = clovers.getCloverMoves(tokenId);\n        address payable _owner = address(uint160(owner()));\n        if (msg.sender != _owner && msg.sender != oracle) {\n            Reversi.Game memory game = Reversi.playGame(moves);\n            if(convertBytes16ToUint(game.board) != tokenId) {\n                valid = false;\n            }\n            if(valid && isValidGame(game.error, game.complete)) {\n                uint256 symmetries = clovers.getSymmetries(tokenId);\n                valid = (symmetries >> 4 & 1) > 0 == game.RotSym ? valid : false;\n                valid = (symmetries >> 3 & 1) > 0 == game.Y0Sym ? valid : false;\n                valid = (symmetries >> 2 & 1) > 0 == game.X0Sym ? valid : false;\n                valid = (symmetries >> 1 & 1) > 0 == game.XYSym ? valid : false;\n                valid = (symmetries & 1) > 0 == game.XnYSym ? valid : false;\n            } else {\n                valid = false;\n            }\n            require(!valid, \"Must be invalid to challenge\");\n        }\n\n        removeSymmetries(tokenId);\n        address committer = clovers.ownerOf(tokenId);\n        emit cloverChallenged(tokenId, moves, committer, msg.sender);\n        clovers.deleteClover(tokenId);\n        return true;\n    }\n\n    function updateSalePrice(uint256 tokenId, uint256 _price) public onlyOwner {\n        simpleCloversMarket.sell(tokenId, _price);\n    }\n\n    /**\n    * @dev Moves clovers without explicit allow permission for use by simpleCloversMarket\n    * in order to avoid double transaction (allow, transferFrom)\n    * @param _from The current owner of the Clover\n    * @param _to The future owner of the Clover\n    * @param tokenId The Clover\n    */\n    function transferFrom(address _from, address _to, uint256 tokenId) public {\n        require(msg.sender == address(simpleCloversMarket), \"transferFrom can only be done by simpleCloversMarket\");\n        clovers.transferFrom(_from, _to, tokenId);\n    }\n\n    /**\n    * @dev Updates pause boolean.\n    * @param _paused The new puased boolean.\n    */\n    function updatePaused(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    /**\n    * @dev Updates oracle Address.\n    * @param _oracle The new oracle Address.\n    */\n    function updateOracle(address _oracle) public onlyOwner {\n        oracle = _oracle;\n    }\n\n    /**\n    * @dev Updates amb Address.\n    * @param _amb The new amb Address.\n    */\n    function updateAMB(IAMB _amb) public onlyOwner {\n        amb = _amb;\n    }\n\n    /**\n    * @dev Updates poaCloversController Address.\n    * @param _poaCloversController The new poaCloversController Address.\n    */\n    function updatePOACloversController(address _poaCloversController) public onlyOwner {\n        poaCloversController = _poaCloversController;\n    }\n\n    /**\n    * @dev Updates simpleCloversMarket Address.\n    * @param _simpleCloversMarket The new simpleCloversMarket address.\n    */\n    function updateSimpleCloversMarket(ISimpleCloversMarket _simpleCloversMarket) public onlyOwner {\n        simpleCloversMarket = _simpleCloversMarket;\n    }\n\n    /**\n    * @dev Updates clubTokenController Address.\n    * @param _clubTokenController The new clubTokenController address.\n    */\n    function updateClubTokenController(IClubTokenController _clubTokenController) public onlyOwner {\n        clubTokenController = _clubTokenController;\n    }\n    /**\n    * @dev Updates the pay multiplier, used to calculate token reward.\n    * @param _payMultiplier The uint256 value of pay multiplier.\n    */\n    function updatePayMultipier(uint256 _payMultiplier) public onlyOwner {\n        payMultiplier = _payMultiplier;\n    }\n    /**\n    * @dev Updates the price multiplier, used to calculate the clover price (multiplied by the original reward).\n    * @param _priceMultiplier The uint256 value of the price multiplier.\n    */\n    function updatePriceMultipier(uint256 _priceMultiplier) public onlyOwner {\n        priceMultiplier = _priceMultiplier;\n    }\n    /**\n    * @dev Updates the base price, used to calculate the clover cost.\n    * @param _basePrice The uint256 value of the base price.\n    */\n    function updateBasePrice(uint256 _basePrice) public onlyOwner {\n        basePrice = _basePrice;\n    }\n\n    /**\n    * @dev Adds new tallys of the totals numbers of clover symmetries.\n    * @param symmetries The symmetries which needs to be added.\n    */\n    function addSymmetries(uint256 symmetries) private {\n        uint256 Symmetricals;\n        uint256 RotSym;\n        uint256 Y0Sym;\n        uint256 X0Sym;\n        uint256 XYSym;\n        uint256 XnYSym;\n        (Symmetricals,\n        RotSym,\n        Y0Sym,\n        X0Sym,\n        XYSym,\n        XnYSym) = clovers.getAllSymmetries();\n        Symmetricals = Symmetricals.add(symmetries > 0 ? 1 : 0);\n        RotSym = RotSym.add(uint256(symmetries >> 4 & 1));\n        Y0Sym = Y0Sym.add(uint256(symmetries >> 3 & 1));\n        X0Sym = X0Sym.add(uint256(symmetries >> 2 & 1));\n        XYSym = XYSym.add(uint256(symmetries >> 1 & 1));\n        XnYSym = XnYSym.add(uint256(symmetries & 1));\n        clovers.setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);\n    }\n    /**\n    * @dev Remove false tallys of the totals numbers of clover symmetries.\n    * @param tokenId The token which needs to be examined.\n    */\n    function removeSymmetries(uint256 tokenId) private {\n        uint256 Symmetricals;\n        uint256 RotSym;\n        uint256 Y0Sym;\n        uint256 X0Sym;\n        uint256 XYSym;\n        uint256 XnYSym;\n        (Symmetricals,\n        RotSym,\n        Y0Sym,\n        X0Sym,\n        XYSym,\n        XnYSym) = clovers.getAllSymmetries();\n        uint256 symmetries = clovers.getSymmetries(tokenId);\n        Symmetricals = Symmetricals.sub(symmetries > 0 ? 1 : 0);\n        RotSym = RotSym.sub(uint256(symmetries >> 4 & 1));\n        Y0Sym = Y0Sym.sub(uint256(symmetries >> 3 & 1));\n        X0Sym = X0Sym.sub(uint256(symmetries >> 2 & 1));\n        XYSym = XYSym.sub(uint256(symmetries >> 1 & 1));\n        XnYSym = XnYSym.sub(uint256(symmetries & 1));\n        clovers.setAllSymmetries(Symmetricals, RotSym, Y0Sym, X0Sym, XYSym, XnYSym);\n    }\n\n    function checkSignature(\n        uint256 tokenId,\n        bytes28[2] memory moves,\n        uint256 symmetries,\n        bool keep,\n        address recipient,\n        bytes memory signature,\n        address signer\n    ) public pure returns (bool) {\n        bytes32 hash = toEthSignedMessageHash(getHash(tokenId, moves, symmetries, keep, recipient));\n        address result = recover(hash, signature);\n        return (result != address(0) && result == signer);\n    }\n\n    function getHash(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, address recipient) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenId, moves, symmetries, keep, recipient));\n    }\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\n        return hash.recover(signature);\n    }\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        return hash.toEthSignedMessageHash();\n    }\n}\n"
    },
    "contracts/v5/Reversi.sol": {
      "content": "pragma solidity ^0.5.8;\n\nlibrary Reversi {\n    // event DebugBool(bool boolean);\n    // event DebugBoard(bytes16 board);\n    // event DebugUint(uint u);\n    uint8 constant BLACK = 1; //0b01 //0x1\n    uint8 constant WHITE = 2; //0b10 //0x2\n    uint8 constant EMPTY = 3; //0b11 //0x3\n\n    struct Game {\n        bool error;\n        bool complete;\n        bool symmetrical;\n        bool RotSym;\n        bool Y0Sym;\n        bool X0Sym;\n        bool XYSym;\n        bool XnYSym;\n        bytes16 board;\n        bytes28 first32Moves;\n        bytes28 lastMoves;\n\n        uint8 currentPlayer;\n        uint8 moveKey;\n        uint8 blackScore;\n        uint8 whiteScore;\n        // string msg;\n    }\n\n\n    function isValid (bytes28[2] memory moves) public pure returns (bool) {\n        Game memory game = playGame(moves);\n        if (game.error) {\n            return false;\n        } else if (!game.complete) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function getGame (bytes28[2] memory moves) public pure returns (\n        bool error,\n        bool complete,\n        bool symmetrical,\n        bytes16 board,\n        uint8 currentPlayer,\n        uint8 moveKey\n    // , string memory msg\n    ) {\n        Game memory game = playGame(moves);\n        return (\n            game.error,\n            game.complete,\n            game.symmetrical,\n            game.board,\n            game.currentPlayer,\n            game.moveKey\n            // , game.msg\n        );\n    }\n\n    function showColors () public pure returns(uint8, uint8, uint8) {\n        return (EMPTY, BLACK, WHITE);\n    }\n\n    function emptyBoard() public pure returns (bytes16) {\n        // game.board = bytes16(10625432672847758622720); // completely empty board\n        return bytes16(uint128(340282366920938456379662753540715053055)); // empty board except for center pieces\n    }\n\n    function playGame (bytes28[2] memory moves) internal pure returns (Game memory)  {\n        Game memory game;\n\n        game.first32Moves = moves[0];\n        game.lastMoves = moves[1];\n        game.moveKey = 0;\n        game.blackScore = 2;\n        game.whiteScore = 2;\n\n        game.error = false;\n        game.complete = false;\n        game.currentPlayer = BLACK;\n\n        game.board = emptyBoard();\n\n        bool skip;\n        uint8 move;\n        uint8 col;\n        uint8 row;\n        uint8 i;\n        bytes28 currentMoves;\n\n        for (i = 0; i < 60 && !skip; i++) {\n            currentMoves = game.moveKey < 32 ? game.first32Moves : game.lastMoves;\n            move = readMove(currentMoves, game.moveKey % 32, 32);\n            (col, row) = convertMove(move);\n            skip = !validMove(move);\n            if (i == 0 && (col != 2 || row != 3)) {\n                skip = true; // this is to force the first move to always be C4 to avoid repeatable boards via mirroring translations\n                game.error = true;\n            }\n            if (!skip && col < 8 && row < 8 && col >= 0 && row >= 0) {\n                // game.msg = \"make a move\";\n                game = makeMove(game, col, row);\n                game.moveKey = game.moveKey + 1;\n                if (game.error) {\n                    if (!validMoveRemains(game)) {\n                        // player has no valid moves and must pass\n                        game.error = false;\n                        if (game.currentPlayer == BLACK) {\n                            game.currentPlayer = WHITE;\n                        } else {\n                            game.currentPlayer = BLACK;\n                        }\n                        game = makeMove(game, col, row);\n                        if (game.error) {\n                            game.error = true;\n                            skip = true;\n                        }\n                    }\n                }\n            }\n        }\n        if (!game.error) {\n            game = isComplete(game);\n            game = isSymmetrical(game);\n        }\n        return game;\n    }\n    /* solium-disable-next-line  security/no-assign-params */\n    function validMoveRemains (Game memory game) internal pure returns (bool) {\n        bool validMovesRemain = false;\n        bytes16 board = game.board;\n        uint8 i;\n        for (i = 0; i < 64 && !validMovesRemain; i++) {\n            uint8[2] memory move = [((i - (i % 8)) / 8), (i % 8)];\n            uint8 tile = returnTile(game.board, move[0], move[1]);\n            if (tile == EMPTY) {\n                game.error = false;\n                game.board = board;\n                game = makeMove(game, move[0], move[1]);\n                if (!game.error) {\n                    validMovesRemain = true;\n                }\n            }\n        }\n        return validMovesRemain;\n    }\n\n    function makeMove (Game memory game, uint8 col, uint8 row) internal pure returns (Game memory)  {\n        // square is already occupied\n        if (returnTile(game.board, col, row) != EMPTY){\n            game.error = true;\n            // game.msg = \"Invalid Game (square is already occupied)\";\n            return game;\n        }\n        int8[2][8] memory possibleDirections;\n        uint8  possibleDirectionsLength;\n        (possibleDirections, possibleDirectionsLength) = getPossibleDirections(game, col, row);\n        // no valid directions\n        if (possibleDirectionsLength == 0) {\n            game.error = true;\n            // game.msg = \"Invalid Game (doesnt border other tiles)\";\n            return game;\n        }\n\n        bytes28 newFlips;\n        uint8 newFlipsLength;\n        uint8 newFlipCol;\n        uint8 newFlipRow;\n        uint8 j;\n        bool valid = false;\n        for (uint8 i = 0; i < possibleDirectionsLength; i++) {\n            delete newFlips;\n            delete newFlipsLength;\n            (newFlips, newFlipsLength) = traverseDirection(game, possibleDirections[i], col, row);\n            for (j = 0; j < newFlipsLength; j++) {\n                if (!valid) valid = true;\n                (newFlipCol, newFlipRow) = convertMove(readMove(newFlips, j, newFlipsLength));\n                game.board = turnTile(game.board, game.currentPlayer, newFlipCol, newFlipRow);\n                if (game.currentPlayer == WHITE) {\n                    game.whiteScore += 1;\n                    game.blackScore -= 1;\n                } else {\n                    game.whiteScore -= 1;\n                    game.blackScore += 1;\n                }\n            }\n        }\n\n        //no valid flips in directions\n        if (valid) {\n            game.board = turnTile(game.board, game.currentPlayer, col, row);\n            if (game.currentPlayer == WHITE) {\n                game.whiteScore += 1;\n            } else {\n                game.blackScore += 1;\n            }\n        } else {\n            game.error = true;\n            // game.msg = \"Invalid Game (doesnt flip any other tiles)\";\n            return game;\n        }\n\n        // switch players\n        if (game.currentPlayer == BLACK) {\n            game.currentPlayer = WHITE;\n        } else {\n            game.currentPlayer = BLACK;\n        }\n        return game;\n    }\n\n    function getPossibleDirections (Game memory game, uint8 col, uint8 row) internal pure returns(int8[2][8] memory, uint8){\n\n        int8[2][8] memory possibleDirections;\n        uint8 possibleDirectionsLength = 0;\n        int8[2][8] memory dirs = [\n            [int8(-1), int8(0)], // W\n            [int8(-1), int8(1)], // SW\n            [int8(0), int8(1)], // S\n            [int8(1), int8(1)], // SE\n            [int8(1), int8(0)], // E\n            [int8(1), int8(-1)], // NE\n            [int8(0), int8(-1)], // N\n            [int8(-1), int8(-1)] // NW\n        ];\n        int8 focusedRowPos;\n        int8 focusedColPos;\n        int8[2] memory dir;\n        uint8 testSquare;\n\n        for (uint8 i = 0; i < 8; i++) {\n            dir = dirs[i];\n            focusedColPos = int8(col) + dir[0];\n            focusedRowPos = int8(row) + dir[1];\n\n            // if tile is off the board it is not a valid move\n            if (!(focusedRowPos > 7 || focusedRowPos < 0 || focusedColPos > 7 || focusedColPos < 0)) {\n                testSquare = returnTile(game.board, uint8(focusedColPos), uint8(focusedRowPos));\n\n                // if the surrounding tile is current color or no color it can\"t be part of a capture\n                if (testSquare != game.currentPlayer) {\n                    if (testSquare != EMPTY) {\n                        possibleDirections[possibleDirectionsLength] = dir;\n                        possibleDirectionsLength++;\n                    }\n                }\n            }\n        }\n        return (possibleDirections, possibleDirectionsLength);\n    }\n\n    function traverseDirection (Game memory game, int8[2] memory dir, uint8 col, uint8 row) internal pure returns(bytes28, uint8) {\n        bytes28 potentialFlips;\n        uint8 potentialFlipsLength = 0;\n        uint8 opponentColor;\n        if (game.currentPlayer == BLACK) {\n            opponentColor = WHITE;\n        } else {\n            opponentColor = BLACK;\n        }\n\n        // take one step at a time in this direction\n        // ignoring the first step look for the same color as your tile\n        bool skip = false;\n        int8 testCol;\n        int8 testRow;\n        uint8 tile;\n        for (uint8 j = 1; j < 9; j++) {\n            if (!skip) {\n                testCol = (int8(j) * dir[0]) + int8(col);\n                testRow = (int8(j) * dir[1]) + int8(row);\n                // ran off the board before hitting your own tile\n                if (testCol > 7 || testCol < 0 || testRow > 7 || testRow < 0) {\n                    delete potentialFlips;\n                    potentialFlipsLength = 0;\n                    skip = true;\n                } else{\n\n                    tile = returnTile(game.board, uint8(testCol), uint8(testRow));\n\n                    if (tile == opponentColor) {\n                        // if tile is opposite color it could be flipped, so add to potential flip array\n                        (potentialFlips, potentialFlipsLength) = addMove(potentialFlips, potentialFlipsLength, uint8(testCol), uint8(testRow));\n                    } else if (tile == game.currentPlayer && j > 1) {\n                        // hit current players tile which means capture is complete\n                        skip = true;\n                    } else {\n                        // either hit current players own color before hitting an opponent\"s\n                        // or hit an empty space\n                        delete potentialFlips;\n                        delete potentialFlipsLength;\n                        skip = true;\n                    }\n                }\n            }\n        }\n        return (potentialFlips, potentialFlipsLength);\n    }\n    /* solium-disable-next-line  security/no-assign-params */\n    function isComplete (Game memory game) internal pure returns (Game memory) {\n        if (game.moveKey == 60) {\n            // game.msg = \"good game\";\n            game.complete = true;\n            return game;\n        } else {\n            uint8 i;\n            bool validMovesRemains = false;\n            bytes16 board = game.board;\n            for (i = 0; i < 64 && !validMovesRemains; i++) {\n                uint8[2] memory move = [((i - (i % 8)) / 8), (i % 8)];\n                uint8 tile = returnTile(game.board, move[0], move[1]);\n                if (tile == EMPTY) {\n                    game.currentPlayer = BLACK;\n                    game.error = false;\n                    game.board = board;\n                    game = makeMove(game, move[0], move[1]);\n                    if (!game.error) {\n                        validMovesRemains = true;\n                    }\n                    game.currentPlayer = WHITE;\n                    game.error = false;\n                    game.board = board;\n                    game = makeMove(game, move[0], move[1]);\n                    if (!game.error) {\n                        validMovesRemains = true;\n                    }\n                }\n            }\n            if (validMovesRemains) {\n                game.error = true;\n                // game.msg = \"Invalid Game (moves still available)\";\n            } else {\n                // game.msg = \"good game\";\n                game.complete = true;\n                game.error = false;\n            }\n        }\n        return game;\n    }\n\n    function isSymmetrical (Game memory game) internal pure returns (Game memory) {\n        bool RotSym = true;\n        bool Y0Sym = true;\n        bool X0Sym = true;\n        bool XYSym = true;\n        bool XnYSym = true;\n        for (uint8 i = 0; i < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); i++) {\n            for (uint8 j = 0; j < 8 && (RotSym || Y0Sym || X0Sym || XYSym || XnYSym); j++) {\n\n                // rotational symmetry\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), (7 - j))) {\n                    RotSym = false;\n                }\n                // symmetry on y = 0\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, i, (7 - j))) {\n                    Y0Sym = false;\n                }\n                // symmetry on x = 0\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - i), j)) {\n                    X0Sym = false;\n                }\n                // symmetry on x = y\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, (7 - j), (7 - i))) {\n                    XYSym = false;\n                }\n                // symmetry on x = -y\n                if (returnBytes(game.board, i, j) != returnBytes(game.board, j, i)) {\n                    XnYSym = false;\n                }\n            }\n        }\n        if (RotSym || Y0Sym || X0Sym || XYSym || XnYSym) {\n            game.symmetrical = true;\n            game.RotSym = RotSym;\n            game.Y0Sym = Y0Sym;\n            game.X0Sym = X0Sym;\n            game.XYSym = XYSym;\n            game.XnYSym = XnYSym;\n        }\n        return game;\n    }\n\n\n\n    // Utilities\n\n    function returnSymmetricals (bool RotSym, bool Y0Sym, bool X0Sym, bool XYSym, bool XnYSym) public pure returns (uint256) {\n        uint256 symmetries = 0;\n        if(RotSym) symmetries |= 16;\n        if(Y0Sym) symmetries |= 8;\n        if(X0Sym) symmetries |= 4;\n        if(XYSym) symmetries |= 2;\n        if(XnYSym) symmetries |= 1;\n        return symmetries;\n    }\n\n\n    function returnBytes (bytes16 board, uint8 col, uint8 row) internal pure returns (bytes16) {\n        uint128 push = posToPush(col, row);\n        return (board >> push) & bytes16(uint128(3));\n    }\n\n    /* solium-disable-next-line  security/no-assign-params */\n    function turnTile (bytes16 board, uint8 color, uint8 col, uint8 row) internal pure returns (bytes16){\n        if (col > 7) revert(\"can't turn tile outside of board col\");\n        if (row > 7) revert(\"can't turn tile outside of board row\");\n        uint128 push = posToPush(col, row);\n        bytes16 mask = bytes16(uint128(3)) << push;// 0b00000011 (ones)\n\n        board = ((board ^ mask) & board);\n\n        return board | (bytes16(uint128(color)) << push);\n    }\n\n    function returnTile (bytes16 board, uint8 col, uint8 row) public pure returns (uint8){\n        uint128 push = posToPush(col, row);\n        bytes16 tile = (board >> push ) & bytes16(uint128(3));\n        return uint8(uint128(tile)); // returns 2\n    }\n\n    function posToPush (uint8 col, uint8 row) internal pure returns (uint128){\n        return uint128(((64) - ((8 * col) + row + 1)) * 2);\n    }\n\n    function readMove (bytes28 moveSequence, uint8 moveKey, uint8 movesLength) public pure returns(uint8) {\n        bytes28 mask = bytes28(uint224(127));\n        uint8 push = (movesLength * 7) - (moveKey * 7) - 7;\n        return uint8(uint224((moveSequence >> push) & mask));\n    }\n\n    /* solium-disable-next-line  security/no-assign-params */\n    function addMove (bytes28 moveSequence, uint8 movesLength, uint8 col, uint8 row) internal pure returns (bytes28, uint8) {\n        uint256 foo = col + (row * 8) + 64;\n        bytes28 move = bytes28(uint224(foo));\n        moveSequence = moveSequence << 7;\n        moveSequence = moveSequence | move;\n        movesLength++;\n        return (moveSequence, movesLength);\n    }\n\n    function validMove (uint8 move) internal pure returns(bool) {\n        return move >= 64;\n    }\n\n    /* solium-disable-next-line  security/no-assign-params */\n    function convertMove (uint8 move) public pure returns(uint8, uint8) {\n        move = move - 64;\n        uint8 col = move % 8;\n        uint8 row = (move - col) / 8;\n        return (col, row);\n    }\n\n}\n"
    },
    "contracts/v5/IAMB.sol": {
      "content": "pragma solidity ^0.5.8;\n\ninterface IAMB {\n    function messageSender() external view returns (address);\n    function maxGasPerTx() external view returns (uint256);\n    function transactionHash() external view returns (bytes32);\n    function messageCallStatus(bytes32 _txHash) external view returns (bool);\n    function failedMessageDataHash(bytes32 _txHash) external view returns (bytes32);\n    function failedMessageReceiver(bytes32 _txHash) external view returns (address);\n    function failedMessageSender(bytes32 _txHash) external view returns (address);\n    function requireToPassMessage(address _contract, bytes calldata _data, uint256 _gas) external;\n}"
    },
    "contracts/v5/IClovers.sol": {
      "content": "pragma solidity ^0.5.8;\n\ncontract IClovers {\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n    function setCloverMoves(uint256 _tokenId, bytes28[2] memory moves) public;\n    function getCloverMoves(uint256 _tokenId) public view returns (bytes28[2] memory);\n    function getAllSymmetries() public view returns (uint256, uint256, uint256, uint256, uint256, uint256);\n    function exists(uint256 _tokenId) public view returns (bool _exists);\n    function getBlockMinted(uint256 _tokenId) public view returns (uint256);\n    function setBlockMinted(uint256 _tokenId, uint256 value) public;\n    function setKeep(uint256 _tokenId, bool value) public;\n    function setSymmetries(uint256 _tokenId, uint256 _symmetries) public;\n    function setReward(uint256 _tokenId, uint256 _amount) public;\n    function mint (address _to, uint256 _tokenId) public;\n    function getReward(uint256 _tokenId) public view returns (uint256);\n    function getKeep(uint256 _tokenId) public view returns (bool);\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n    function moveEth(address _to, uint256 _amount) public;\n    function getSymmetries(uint256 _tokenId) public view returns (uint256);\n    function deleteClover(uint256 _tokenId) public;\n    function setAllSymmetries(uint256 _totalSymmetries, uint256 RotSym, uint256 Y0Sym, uint256 X0Sym, uint256 XYSym, uint256 XnYSym) public;\n}"
    },
    "contracts/v5/IClubToken.sol": {
      "content": "pragma solidity ^0.5.8;\n\ncontract IClubToken {\n    function balanceOf(address _owner) public view returns (uint256);\n    function burn(address _burner, uint256 _value) public;\n    function mint(address _to, uint256 _amount) public returns (bool);\n}"
    },
    "contracts/v5/IClubTokenController.sol": {
      "content": "pragma solidity ^0.5.8;\n\ncontract IClubTokenController {\n    function buy(address buyer) public payable returns(bool);\n}"
    },
    "contracts/v5/ISimpleCloversMarket.sol": {
      "content": "pragma solidity ^0.5.8;\n\ncontract ISimpleCloversMarket {\n    function sell(uint256 _tokenId, uint256 price) public;\n}"
    },
    "contracts/v5/POACloversController.sol": {
      "content": "pragma solidity ^0.5.8;\n\n/**\n * The POACloversController is a replaceable endpoint for minting and unminting Clovers.sol and ClubToken.sol\n */\n\nimport \"./Reversi.sol\";\nimport \"./IAMB.sol\";\nimport \"./CloversController.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\ncontract POACloversController is Ownable {\n    event cloverClaimed(uint256 tokenId, bytes28[2] moves, address sender, address recipient, uint reward, uint256 symmetries, bool keep);\n\n    using SafeMath for uint256;\n    using ECDSA for bytes32;\n\n    bool public paused;\n    address public oracle;\n    IAMB public amb;\n    CloversController public cloversController;\n    uint256 public executionGasLimit;\n\n    mapping(bytes32=>Submission) public submissions;\n\n    struct Submission {\n        uint256 tokenId;\n        bytes28[2] moves;\n        uint256 symmetries;\n        address recipient;\n        bool keep;\n    }\n\n    function setMessageHashValue(bytes32 _hash, uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, address recipient, bool keep)\n        internal {\n        require(submissions[_hash].tokenId == 0, \"Hash has already been submitted\");\n        submissions[_hash] = Submission(tokenId, moves, symmetries, recipient, keep);\n    }\n\n    modifier notPaused() {\n        require(!paused, \"Must not be paused\");\n        _;\n    }\n\n    constructor(\n        IAMB _amb,\n        uint256 _executionGasLimit\n    ) public {\n        amb = _amb;\n        executionGasLimit = _executionGasLimit;\n    }\n\n    function getMovesHash(bytes28[2] memory moves) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(moves));\n    }\n\n    function getMovesHashWithRecipient(bytes32 movesHash, address recipient) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(movesHash, recipient));\n    }\n\n    /**\n    * @dev Checks whether the game is valid.\n    * @param moves The moves needed to play validate the game.\n    * @return A boolean representing whether or not the game is valid.\n    */\n    function isValid(bytes28[2] memory moves) public pure returns (bool) {\n        Reversi.Game memory game = Reversi.playGame(moves);\n        return isValidGame(game.error, game.complete);\n    }\n\n    /**\n    * @dev Checks whether the game is valid.\n    * @param error The pre-played game error\n    * @param complete The pre-played game complete boolean\n    * @return A boolean representing whether or not the game is valid.\n    */\n    function isValidGame(bool error, bool complete) public pure returns (bool) {\n        if (error || !complete) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function getGame (bytes28[2] memory moves) public pure returns\n        (bool error, bool complete, bool symmetrical, bytes16 board, uint8 currentPlayer, uint8 moveKey) {\n        // return Reversi.getGame(moves);\n        Reversi.Game memory game = Reversi.playGame(moves);\n        return (\n            game.error,\n            game.complete,\n            game.symmetrical,\n            game.board,\n            game.currentPlayer,\n            game.moveKey\n            // game.msg\n        );\n    }\n\n    // In order to prevent commit reveal griefing the first commit is a combined hash of the moves and the recipient.\n    // In order to use the same commit mapping, we mark this hash simply as address(1) so it is no longer the equivalent of address(0)\n    function claimCloverSecurelyPartOne(bytes32 movesHashWithRecipient, address recipient) public {\n        bytes4 methodSelector = CloversController(address(0)).claimCloverSecurelyPartOne.selector;\n        bytes memory data = abi.encodeWithSelector(methodSelector, movesHashWithRecipient, recipient);\n        amb.requireToPassMessage(address(cloversController), data, executionGasLimit); // TODO: set different gas limits\n\n    }\n\n    // Once a commit has been made to guarantee the move hash is associated with the recipient we can make a commit on the hash of the moves themselves\n    // If we were to make a claim on the moves in plaintext, the transaction could be front run on the claimCloverWithVerification or the claimCloverWithSignature\n    function claimCloverSecurelyPartTwo(bytes32 movesHash, address recipient) public {\n        bytes4 methodSelector = CloversController(address(0)).claimCloverSecurelyPartTwo.selector;\n        bytes memory data = abi.encodeWithSelector(methodSelector, movesHash, recipient);\n        amb.requireToPassMessage(address(cloversController), data, executionGasLimit); // TODO: set different gas limits\n    }\n\n    function claimCloverWithVerification(bytes28[2] memory moves, bool keep, address recipient) public payable returns (bool) {\n        Reversi.Game memory game = Reversi.playGame(moves);\n        require(isValidGame(game.error, game.complete), \"Invalid game\");\n        uint256 tokenId = convertBytes16ToUint(game.board);\n\n        uint256 symmetries = Reversi.returnSymmetricals(game.RotSym, game.Y0Sym, game.X0Sym, game.XYSym, game.XnYSym);\n        require(_claimClover(tokenId, moves, symmetries, recipient, keep), \"Claim must succeed\");\n        return true;\n    }\n\n\n\n    /**\n    * @dev Claim the Clover without a commit or reveal. Payable so you can buy tokens if needed.\n    * @param tokenId The board that results from the moves.\n    * @param moves The moves that make up the Clover reversi game.\n    * @param symmetries symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * @param keep symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * @param signature symmetries saved as a uint256 value like 00010101 where bits represent symmetry\n    * types.\n    * @return A boolean representing whether or not the claim was successful.\n    */\n    /* solium-disable-next-line  max-len */\n    function claimCloverWithSignature(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, address recipient, bytes memory signature)\n        public payable notPaused returns (bool) {\n        require(checkSignature(tokenId, moves, symmetries, keep, recipient, signature, oracle), \"Invalid Signature\");\n        require(_claimClover(tokenId, moves, symmetries, recipient, keep), \"Claim must succeed\");\n        return true;\n    }\n\n    function _claimClover(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, address recipient, bool keep) internal returns (bool) {\n\n        bytes4 methodSelector = CloversController(address(0)).claimCloverFromAMB.selector;\n        bytes memory data = abi.encodeWithSelector(methodSelector, tokenId, moves, symmetries, keep, recipient);\n        amb.requireToPassMessage(address(cloversController), data, executionGasLimit);\n\n        // Save value and from related to the data hash in case the message fails on the other side\n        // bytes32 dataHash = keccak256(data);\n        // setMessageHashValue(dataHash, tokenId, moves, symmetries, recipient, keep);\n        return true;\n    }\n\n\n    /**\n    * @dev Convert a bytes16 board into a uint256.\n    * @param _board The board being converted.\n    * @return number the uint256 being converted.\n    */\n    function convertBytes16ToUint(bytes16 _board) public pure returns(uint256 number) {\n        for(uint i = 0;i<_board.length;i++){\n            number = number + uint(uint8(_board[i]))*(2**(8*(_board.length-(i+1))));\n        }\n    }\n\n    /**\n    * @dev Updates pause boolean.\n    * @param _paused The new puased boolean.\n    */\n    function updatePaused(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n\n    /**\n    * @dev Updates oracle Address.\n    * @param _oracle The new oracle Address.\n    */\n    function updateOracle(address _oracle) public onlyOwner {\n        oracle = _oracle;\n    }\n\n    /**\n    * @dev Updates arbitrary message bridge Address.\n    * @param _amb The new amb address.\n    */\n    function updateAMB(IAMB _amb) public onlyOwner {\n        amb = _amb;\n    }\n\n    /**\n    * @dev Updates executionGasLimit.\n    * @param _executionGasLimit The new executionGasLimit.\n    */\n    function updateExecutionGasLimit(uint256 _executionGasLimit) public onlyOwner {\n        executionGasLimit = _executionGasLimit;\n    }\n\n    /**\n    * @dev Updates cloversController Address.\n    * @param _cloversController The new cloversController address.\n    */\n    function updateCloversController(CloversController _cloversController) public onlyOwner {\n        cloversController = _cloversController;\n    }\n\n    function checkSignature(\n        uint256 tokenId,\n        bytes28[2] memory moves,\n        uint256 symmetries,\n        bool keep,\n        address recipient,\n        bytes memory signature,\n        address signer\n    ) public pure returns (bool) {\n        bytes32 hash = toEthSignedMessageHash(getHash(tokenId, moves, symmetries, keep, recipient));\n        address result = recover(hash, signature);\n        return (result != address(0) && result == signer);\n    }\n\n    function getHash(uint256 tokenId, bytes28[2] memory moves, uint256 symmetries, bool keep, address recipient) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenId, moves, symmetries, keep, recipient));\n    }\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\n        return hash.recover(signature);\n    }\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        return hash.toEthSignedMessageHash();\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * (.note) This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * (.warning) `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise)\n     * be too long), and then calling `toEthSignedMessageHash` on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\n     * JSON-RPC method.\n     *\n     * See `recover`.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/v5/EDSAMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\ncontract ECDSAMock {\n    using ECDSA for bytes32;\n\n    function getHash(uint256 tokenId, bytes28[2] memory moves) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(tokenId, moves));\n    }\n\n    function getHashWithPrefix(uint256 tokenId, bytes28[2] memory moves) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\u0019Ethereum Signed Message:\\n\", tokenId, moves));\n    }\n\n    function checkClover(address signer, bytes memory signature, uint256 tokenId, bytes28[2] memory moves) public pure returns (bool) {\n        bytes32 hash = toEthSignedMessageHash(getHash(tokenId, moves));\n        address result = recover(hash, signature);\n        return result == signer;\n    }\n\n    function recover(bytes32 hash, bytes memory signature) public pure returns (address) {\n        return hash.recover(signature);\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) {\n        return hash.toEthSignedMessageHash();\n    }\n}\n"
    },
    "contracts/v5/mocks/ReversiMock.sol": {
      "content": "pragma solidity ^0.5.8;\n\n/**\n * ReversiMock helps w testing Reversi.sol\n */\n\nimport \"../Reversi.sol\";\n\n\ncontract ReversiMock {\n    function logGame(bytes28[2] memory moves) public {\n        Reversi.playGame(moves);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}